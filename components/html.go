package components

import (
	"fmt"
	"strings"
	"sync"
	// "syscall/js"
)

// Node represents an HTML element node
type Node struct {
	Tag        string
	Attributes Attributes
	Children   []NodeInterface
}

// Attributes represents HTML attributes
type Attributes map[string]string

// NodeInterface is a common interface for all types of nodes
type NodeInterface interface {
	Render() string
	Print(indentLevel int) string
}

// TextNode represents a text node
type TextNode struct {
	Content string
}

// NewTextNode creates a new TextNode
func NewTextNode(content string) *TextNode {
	return &TextNode{Content: content}
}

// Render renders the text node as a string
func (t *TextNode) Render() string {
	return t.Content
}

// Print renders the text node with indentation
func (t *TextNode) Print(indentLevel int) string {
	return strings.Repeat("\t", indentLevel) + t.Content
}

// ElementNode represents an HTML element node
func (n *Node) Render() string {
	// Render attributes
	attrStr := ""
	for key, value := range n.Attributes {
		attrStr += fmt.Sprintf(` %s="%s"`, key, value)
	}

	// Check if the tag is a void tag
	if isVoidTag(n.Tag) {
		// Return the self-closing tag for void elements
		return fmt.Sprintf("<%s%s />", n.Tag, attrStr)
	}

	// Render children for non-void tags
	childrenStr := ""
	for _, child := range n.Children {
		childrenStr += child.Render()
	}

	// Return the full HTML element
	return fmt.Sprintf("<%s%s>%s</%s>", n.Tag, attrStr, childrenStr, n.Tag)
}

// Print renders the element node with indentation
func (n *Node) Print(indentLevel int) string {
	// Render attributes
	attrStr := ""
	for key, value := range n.Attributes {
		attrStr += fmt.Sprintf(` %s="%s"`, key, value)
	}

	// Indentation for opening tag or self-closing tag
	if isVoidTag(n.Tag) {
		// Self-closing tag for void elements
		return strings.Repeat("\t", indentLevel) + fmt.Sprintf("<%s%s />", n.Tag, attrStr)
	}

	// Normal opening tag for non-void elements
	result := strings.Repeat("\t", indentLevel) + fmt.Sprintf("<%s%s>\n", n.Tag, attrStr)

	// Indentation for children
	for _, child := range n.Children {
		result += child.Print(indentLevel + 1) + "\n"
	}

	// Indentation for closing tag
	result += strings.Repeat("\t", indentLevel) + fmt.Sprintf("</%s>", n.Tag)

	return result
}

var (
	idCounter   int
	idMutex     sync.Mutex
	// domRegistry = make(map[string]js.Value) // Map to store DOM references by binding ID
)

// generateBindingID generates a unique ID for each tag node to be used in the custom data attribute
func generateBindingID() string {
	idMutex.Lock()
	defer idMutex.Unlock()
	idCounter++
	return fmt.Sprintf("go_binding_%d", idCounter)
}

// Tag creates an HTML element node with an autogenerated binding ID if not provided
func Tag(name string, attrs Attributes, children ...NodeInterface) *Node {
	// Add a custom data attribute for Go binding
	if _, exists := attrs["data-go_binding_id"]; !exists {
		attrs["data-go_binding_id"] = generateBindingID()
	}

	return &Node{
		Tag:        name,
		Attributes: attrs,
		Children:   children,
	}
}

// Text creates a TextNode
func Text(content string) NodeInterface {
	return NewTextNode(content)
}

// isVoidTag checks if a tag is a void tag (self-closing)
func isVoidTag(tag string) bool {
	voidTags := []string{"area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "source", "track", "wbr"}
	for _, voidTag := range voidTags {
		if tag == voidTag {
			return true
		}
	}
	return false
}

// RegisterTagReference registers a tag reference from the DOM using its binding ID
// func RegisterTagReference(bindingID string) {
// 	// Query the DOM for the element with the given binding ID
// 	element := js.Global().Get("document").Call("querySelector", fmt.Sprintf(`[data-go_binding_id="%s"]`, bindingID))

// 	// Store the reference in the domRegistry map
// 	if !element.IsNull() && !element.IsUndefined() {
// 		domRegistry[bindingID] = element
// 	} else {
// 		fmt.Printf("Element with data-go_binding_id='%s' not found in the DOM.\n", bindingID)
// 	}
// }

// Validation function example: checks if the node's tag is valid HTML
func validateTag(node *Node) error {
	validTags := []string{"div", "span", "p", "a", "button", "select", "option", "input", "form", "label"} // Extend as needed
	for _, validTag := range validTags {
		if node.Tag == validTag || isVoidTag(node.Tag) {
			return nil
		}
	}
	return fmt.Errorf("invalid tag: %s", node.Tag)
}

// ValidateNode runs validation rules on the node tree
func ValidateNode(node *Node) error {
	if node == nil {
		return nil
	}

	// Validate the current node
	if err := validateTag(node); err != nil {
		return err
	}

	// Recursively validate children
	for _, child := range node.Children {
		if elementNode, ok := child.(*Node); ok {
			if err := ValidateNode(elementNode); err != nil {
				return err
			}
		}
	}

	return nil
}

// RenderAndValidateNodeTree renders the node tree to an HTML string and validates it
func RenderAndValidateNodeTree(root NodeInterface) (string, error) {
	// Render the node tree to an HTML string
	html := root.Render()

	// Validate the node tree if it's a Node (and not a TextNode)
	if elementNode, ok := root.(*Node); ok {
		if err := ValidateNode(elementNode); err != nil {
			return "", err
		}
	}

	return html, nil
}

// PrintNodeTree prints the node tree with appropriate indentation
func PrintNodeTree(root NodeInterface) {
	fmt.Print(root.Print(0))
}

// Println prints the node tree with appropriate indentation and adds a newline at the end
func Println(root NodeInterface) {
	fmt.Println(root.Print(0))
}
